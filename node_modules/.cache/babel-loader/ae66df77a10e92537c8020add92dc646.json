{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _initializerDefineProperty from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _applyDecoratedDescriptor from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _temp;\n\nimport { observable, action, computed } from 'mobx';\nimport GameObjectTypes from '../shared/enum/GameObjectTypes';\nimport directions from '../shared/enum/directions';\nimport uuid from 'uuid';\nimport { MS_FRAME_SCALE } from './GameState';\nvar GRAVITY = 0.6;\nvar GameObject = (_class = (_temp = /*#__PURE__*/function () {\n  function GameObject() {\n    var _this = this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GameObject);\n\n    this.type = GameObjectTypes.GameObject;\n    this.id = uuid.v4();\n    this.movementFreezes = {};\n\n    _initializerDefineProperty(this, \"position\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"velocity\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"freefall\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"spritePosition\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"spriteUrl\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"spriteScale\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"spriteWidth\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"spriteHeight\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"screenWidth\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"screenHeight\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"isForeground\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"isAffectedByGravity\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"hasShadow\", _descriptor13, this);\n\n    this.animationState = {\n      trackName: null,\n      startTime: 0\n    };\n\n    _initializerDefineProperty(this, \"direction\", _descriptor14, this);\n\n    this.removeFromGame = function () {\n      _this.gameState.removeGameObject(_this);\n    };\n\n    if (props.position) {\n      this.position = _objectSpread({}, props.position);\n    }\n\n    this.level = props.level;\n    this.camera = props.camera;\n    this.gameState = props.gameState;\n  }\n\n  _createClass(GameObject, [{\n    key: \"step\",\n    value: function step(deltaTime) {\n      if (this.inFreefall()) {\n        this.stepFreefall(deltaTime);\n      } else if (!this.isMovementFrozen() && !this.isDead) {\n        this.stepMovement(deltaTime);\n      }\n\n      this.stepAnimation();\n    }\n  }, {\n    key: \"integrateVelocity\",\n    value: function integrateVelocity(velocity, deltaTime) {\n      //Add gravity to y-velocity, if in the air\n      if (!this.onGround && this.isAffectedByGravity) {\n        velocity.y -= GRAVITY * deltaTime * MS_FRAME_SCALE;\n      }\n\n      this.position.x += velocity.x * deltaTime * MS_FRAME_SCALE;\n      this.position.y += velocity.y * deltaTime * MS_FRAME_SCALE;\n      this.position.z += velocity.z * deltaTime * MS_FRAME_SCALE; //Prevent falling through the ground\n\n      if (this.position.y <= 0 && velocity.y < 0) {\n        this.position.y = 0;\n        velocity.y = 0;\n        this.onReturnToGround();\n      }\n    }\n  }, {\n    key: \"stepFreefall\",\n    value: function stepFreefall(deltaTime) {\n      var _this2 = this;\n\n      this.integrateVelocity(this.freefall.velocity, deltaTime);\n\n      if (this.freefall && this.freefall.damage) {\n        this.gameState.getGameObjectsInsideBox(this.getBoundingBox()).forEach(function (gameObject) {\n          if (gameObject !== _this2 && gameObject.canTakeDamage && !gameObject.isDead) {\n            gameObject.takeDamage(_this2.freefall.damage, _this2.position.x < gameObject.position.x ? directions.left : directions.right, _this2);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"stepMovement\",\n    value: function stepMovement(deltaTime) {\n      this.integrateVelocity(this.velocity, deltaTime);\n    }\n  }, {\n    key: \"stepAnimation\",\n    value: function stepAnimation() {\n      var _this$animationState = this.animationState,\n          trackName = _this$animationState.trackName,\n          startTime = _this$animationState.startTime;\n\n      if (!trackName) {\n        return;\n      }\n\n      var _this$animationTracks = this.animationTracks[trackName],\n          duration = _this$animationTracks.duration,\n          frames = _this$animationTracks.frames,\n          loopStartFrame = _this$animationTracks.loopStartFrame,\n          introDuration = _this$animationTracks.introDuration;\n      var now = performance.now();\n      var currentFrame;\n\n      if (loopStartFrame) {\n        if (now - startTime <= introDuration) {\n          currentFrame = Math.floor((now - startTime) / introDuration * loopStartFrame);\n        } else {\n          currentFrame = loopStartFrame + Math.floor((now - startTime - introDuration) / duration % 1 * (frames.length - loopStartFrame));\n        }\n      } else {\n        currentFrame = Math.floor((now - startTime) / duration % 1 * frames.length);\n      }\n\n      this.spritePosition.x = frames[currentFrame].x;\n      this.spritePosition.y = frames[currentFrame].y;\n      this.spriteWidth = frames[currentFrame].width || this.screenWidth;\n      this.spriteHeight = frames[currentFrame].height || this.screenHeight;\n    }\n  }, {\n    key: \"onReturnToGround\",\n    value: function onReturnToGround() {\n      this.freefall = null;\n    }\n  }, {\n    key: \"setAnimation\",\n    value: function setAnimation(trackName) {\n      if (this.animationState.trackName === trackName) {\n        return;\n      }\n\n      this.animationState = {\n        trackName: trackName,\n        startTime: performance.now()\n      };\n    }\n  }, {\n    key: \"freezeMovement\",\n    value: function freezeMovement(duration, reason) {\n      this.movementFreezes[reason] = performance.now() + duration;\n    }\n  }, {\n    key: \"clearMovementFreezes\",\n    value: function clearMovementFreezes() {\n      this.movementFreezes = {};\n    }\n  }, {\n    key: \"isMovementFrozen\",\n    value: function isMovementFrozen() {\n      var now = performance.now();\n      return Object.values(this.movementFreezes).some(function (frozenUntilTime) {\n        return frozenUntilTime >= now;\n      });\n    }\n  }, {\n    key: \"setFreefall\",\n    value: function setFreefall(velocity) {\n      var damage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Zero out any current y-velocity, since the freefall will take the object back to the ground\n      this.velocity.y = 0;\n      this.freefall = {\n        velocity: velocity,\n        damage: damage\n      };\n    }\n  }, {\n    key: \"inFreefall\",\n    value: function inFreefall() {\n      return !!this.freefall;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      return {\n        x: {\n          min: this.position.x,\n          max: this.position.x + this.collisionWidth\n        },\n        y: {\n          min: this.position.y + this.collisionBottom,\n          max: this.position.y + this.collisionHeight\n        },\n        z: {\n          min: this.position.z - this.collisionDepth,\n          max: this.position.z + this.collisionDepth\n        }\n      };\n    }\n  }, {\n    key: \"onGround\",\n    get: function get() {\n      return this.position.y === 0;\n    }\n  }]);\n\n  return GameObject;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"position\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"velocity\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"freefall\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return null;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"spritePosition\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"spriteUrl\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"spriteScale\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"spriteWidth\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"spriteHeight\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"screenWidth\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"screenHeight\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"isForeground\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"isAffectedByGravity\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return true;\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"hasShadow\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return true;\n  }\n}), _descriptor14 = _applyDecoratedDescriptor(_class.prototype, \"direction\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return directions.right;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"step\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"step\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"integrateVelocity\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"integrateVelocity\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"stepFreefall\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"stepFreefall\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"stepMovement\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"stepMovement\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"stepAnimation\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"stepAnimation\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"onGround\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"onGround\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"onReturnToGround\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"onReturnToGround\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setAnimation\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"setAnimation\"), _class.prototype)), _class);\nexport default GameObject;","map":{"version":3,"sources":["C:/Users/Admin/Documents/Crane/Capstone-Crane/src/state/GameObject.js"],"names":["observable","action","computed","GameObjectTypes","directions","uuid","MS_FRAME_SCALE","GRAVITY","GameObject","props","type","id","v4","movementFreezes","animationState","trackName","startTime","removeFromGame","gameState","removeGameObject","position","level","camera","deltaTime","inFreefall","stepFreefall","isMovementFrozen","isDead","stepMovement","stepAnimation","velocity","onGround","isAffectedByGravity","y","x","z","onReturnToGround","integrateVelocity","freefall","damage","getGameObjectsInsideBox","getBoundingBox","forEach","gameObject","canTakeDamage","takeDamage","left","right","animationTracks","duration","frames","loopStartFrame","introDuration","now","performance","currentFrame","Math","floor","length","spritePosition","spriteWidth","width","screenWidth","spriteHeight","height","screenHeight","reason","Object","values","some","frozenUntilTime","min","max","collisionWidth","collisionBottom","collisionHeight","collisionDepth"],"mappings":"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","sourcesContent":["import { observable, action, computed } from 'mobx'\r\nimport GameObjectTypes from '../shared/enum/GameObjectTypes'\r\nimport directions from '../shared/enum/directions'\r\nimport uuid from 'uuid'\r\nimport { MS_FRAME_SCALE } from './GameState'\r\n\r\nconst GRAVITY = 0.6\r\n\r\nclass GameObject {\r\n\r\n  type = GameObjectTypes.GameObject\r\n  id = uuid.v4()\r\n  movementFreezes = {}\r\n\r\n  @observable\r\n  position = {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0,\r\n  }\r\n\r\n  @observable\r\n  velocity = {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0,\r\n  }\r\n\r\n  @observable\r\n  freefall = null\r\n\r\n  @observable\r\n  spritePosition = {\r\n    x: 0,\r\n    y: 0\r\n  }\r\n\r\n  @observable\r\n  spriteUrl = ''\r\n\r\n  @observable\r\n  spriteScale = 0\r\n\r\n  @observable\r\n  spriteWidth = 0 \r\n\r\n  @observable\r\n  spriteHeight = 0  \r\n\r\n  @observable\r\n  screenWidth = 0\r\n\r\n  @observable\r\n  screenHeight = 0\r\n\r\n  @observable\r\n  isForeground = false\r\n\r\n  @observable\r\n  isAffectedByGravity = true\r\n\r\n  @observable\r\n  hasShadow = true\r\n\r\n  animationState = {\r\n    trackName: null,\r\n    startTime: 0,\r\n  };\r\n\r\n  @observable\r\n  direction = directions.right\r\n\r\n  constructor( props = {} ) {\r\n    if ( props.position ) {\r\n      this.position = { ...props.position }\r\n    }\r\n    this.level = props.level\r\n    this.camera = props.camera\r\n    this.gameState = props.gameState\r\n  }\r\n\r\n  @action\r\n  step( deltaTime ) {\r\n    if ( this.inFreefall() ) {\r\n      this.stepFreefall( deltaTime )\r\n    }\r\n    else if ( !this.isMovementFrozen() && !this.isDead ) {\r\n      this.stepMovement( deltaTime )\r\n    }\r\n    this.stepAnimation()\r\n  }\r\n\r\n  @action\r\n  integrateVelocity( velocity, deltaTime ) {\r\n    //Add gravity to y-velocity, if in the air\r\n    if ( !this.onGround && this.isAffectedByGravity ) {\r\n      velocity.y -= GRAVITY * deltaTime * MS_FRAME_SCALE\r\n    }\r\n\r\n    this.position.x += velocity.x * deltaTime * MS_FRAME_SCALE\r\n    this.position.y += velocity.y * deltaTime * MS_FRAME_SCALE\r\n    this.position.z += velocity.z * deltaTime * MS_FRAME_SCALE\r\n\r\n    //Prevent falling through the ground\r\n    if ( this.position.y <= 0 && velocity.y < 0 ) {\r\n      this.position.y = 0\r\n      velocity.y = 0\r\n      this.onReturnToGround()\r\n    }\r\n  }\r\n\r\n  @action\r\n  stepFreefall( deltaTime ) {\r\n    this.integrateVelocity( this.freefall.velocity, deltaTime )\r\n    if ( this.freefall && this.freefall.damage ) {\r\n      \r\n      this.gameState.getGameObjectsInsideBox( this.getBoundingBox() ).forEach( gameObject => {\r\n        if ( gameObject !== this && gameObject.canTakeDamage && !gameObject.isDead ) {\r\n          gameObject.takeDamage( this.freefall.damage, this.position.x < gameObject.position.x ? directions.left : directions.right, this )\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  @action\r\n  stepMovement( deltaTime ) {\r\n    this.integrateVelocity( this.velocity, deltaTime )\r\n  }\r\n\r\n  @action\r\n  stepAnimation() {\r\n    const { trackName, startTime } = this.animationState\r\n    if ( !trackName ) {\r\n      return\r\n    }\r\n\r\n    const {\r\n      duration,\r\n      frames,\r\n      loopStartFrame,\r\n      introDuration,\r\n    } = this.animationTracks[ trackName ]\r\n    \r\n    const now = performance.now()\r\n    let currentFrame\r\n    if ( loopStartFrame ) {\r\n      if ( now - startTime <= introDuration ) {\r\n        currentFrame = Math.floor(( now - startTime ) / introDuration  * loopStartFrame )\r\n      }\r\n      else {\r\n        currentFrame = loopStartFrame + Math.floor((( now - startTime - introDuration ) / duration % 1 ) * ( frames.length - loopStartFrame ))\r\n      }\r\n    }\r\n    else {\r\n      currentFrame = Math.floor((( now - startTime ) / duration % 1 ) * frames.length)  \r\n    }\r\n    \r\n      \r\n    this.spritePosition.x = frames[ currentFrame ].x\r\n    this.spritePosition.y = frames[ currentFrame ].y\r\n    this.spriteWidth = frames[ currentFrame ].width || this.screenWidth\r\n    this.spriteHeight = frames[ currentFrame ].height || this.screenHeight\r\n  }\r\n\r\n  @computed\r\n  get onGround() {\r\n    return this.position.y === 0\r\n  }\r\n\r\n  @action\r\n  onReturnToGround() {\r\n    this.freefall = null\r\n  }\r\n\r\n  @action\r\n  setAnimation( trackName ) {\r\n    if ( this.animationState.trackName === trackName ) {\r\n      return\r\n    }\r\n\r\n    this.animationState = {\r\n      trackName,\r\n      startTime: performance.now(),\r\n    }\r\n  }\r\n\r\n  freezeMovement( duration, reason ) {\r\n    this.movementFreezes[ reason ] = performance.now() + duration\r\n  }\r\n\r\n  clearMovementFreezes() {\r\n    this.movementFreezes = {}\r\n  }\r\n\r\n  isMovementFrozen() {\r\n    const now = performance.now()\r\n    return Object.values( this.movementFreezes ).some( frozenUntilTime => frozenUntilTime >= now )\r\n  }\r\n\r\n  setFreefall( velocity, damage = 0 ) {\r\n    // Zero out any current y-velocity, since the freefall will take the object back to the ground\r\n    this.velocity.y = 0\r\n\r\n    this.freefall = {\r\n      velocity,\r\n      damage\r\n    }\r\n  }\r\n\r\n  inFreefall() {\r\n    return !!this.freefall\r\n  }\r\n\r\n  removeFromGame = () => {\r\n    this.gameState.removeGameObject( this )\r\n  }\r\n\r\n  getBoundingBox() {\r\n    return {\r\n      x: { min: this.position.x, max: this.position.x + this.collisionWidth },\r\n      y: { min: this.position.y + this.collisionBottom, max: this.position.y + this.collisionHeight },\r\n      z: { min: this.position.z - this.collisionDepth, max: this.position.z + this.collisionDepth }\r\n    }\r\n  }\r\n}\r\n\r\nexport default GameObject"]},"metadata":{},"sourceType":"module"}