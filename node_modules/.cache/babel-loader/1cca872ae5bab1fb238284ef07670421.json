{"ast":null,"code":"import _initializerDefineProperty from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _applyDecoratedDescriptor from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"C:\\\\Users\\\\Admin\\\\Documents\\\\Crane\\\\Capstone-Crane\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _temp;\n\nimport GameObject from './GameObject';\nimport { action, observable } from 'mobx';\nimport directions from '../shared/enum/directions'; // A GameObject that can attack and take damage\n\nvar DAMAGE_FLYBACK_X = 4;\nvar DAMAGE_FLYBACK_Y = 5;\nvar DAMAGE_RANGE_NEAR_X = 25;\nvar DAMAGE_RANGE_FAR_X = 30;\nvar DAMAGE_RANGE_Z = 15;\nvar GameCharacter = (_class = (_temp = /*#__PURE__*/function (_GameObject) {\n  _inherits(GameCharacter, _GameObject);\n\n  function GameCharacter(props) {\n    var _this;\n\n    _classCallCheck(this, GameCharacter);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GameCharacter).call(this, props));\n\n    _initializerDefineProperty(_this, \"courage\", _descriptor, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    _initializerDefineProperty(_this, \"damageDealt\", _descriptor2, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    _initializerDefineProperty(_this, \"kills\", _descriptor3, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this.canTakeDamage = true;\n    _this.isDead = false;\n\n    _this.getAttackBox = function () {\n      var minX, maxX;\n\n      if (_this.direction === directions.right) {\n        minX = _this.position.x + _this.collisionWidth + DAMAGE_RANGE_NEAR_X;\n        maxX = _this.position.x + _this.collisionWidth + DAMAGE_RANGE_FAR_X;\n      } else {\n        maxX = _this.position.x - DAMAGE_RANGE_NEAR_X;\n        minX = _this.position.x - DAMAGE_RANGE_FAR_X;\n      }\n\n      return {\n        x: {\n          min: minX,\n          max: maxX\n        },\n        y: {\n          min: _this.position.y,\n          max: _this.position.y + _this.collisionHeight\n        },\n        z: {\n          min: _this.position.z - DAMAGE_RANGE_Z,\n          max: _this.position.z + DAMAGE_RANGE_Z\n        }\n      };\n    };\n\n    _initializerDefineProperty(_this, \"doAttackDamage\", _descriptor4, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this.onDie = props.onDie;\n    return _this;\n  }\n\n  _createClass(GameCharacter, [{\n    key: \"attack\",\n    value: function attack(animation, damageDelay) {\n      if (!this.isMovementFrozen() && this.onGround) {\n        this.attacking = true;\n        this.setAnimation(animation);\n        var duration = this.animationTracks[animation].duration;\n        this.freezeMovement(duration, 'attack');\n        this.attackDamageTimeout = setTimeout(this.doAttackDamage, damageDelay);\n      }\n    }\n  }, {\n    key: \"takeDamage\",\n    value: function takeDamage(damage, fromDirection, fromGameCharacter) {\n      if (this.isCurrentlyTakingDamage) {\n        return;\n      }\n\n      this.courage -= damage;\n      fromGameCharacter.damageDealt += damage;\n      this.clearMovementFreezes(); // Clear movement freezes because the character is about to be knocked backwards\n\n      clearTimeout(this.attackDamageTimeout); // Interrupt any in-progress attack\n\n      this.isCurrentlyTakingDamage = true;\n      this.setAnimation('take_damage');\n      this.direction = fromDirection;\n      this.setFreefall({\n        x: fromDirection === directions.left ? DAMAGE_FLYBACK_X : -DAMAGE_FLYBACK_X,\n        y: DAMAGE_FLYBACK_Y,\n        z: 0\n      });\n\n      if (this.courage <= 0) {\n        this.die();\n        fromGameCharacter.kills += 1;\n      }\n    }\n  }, {\n    key: \"onReturnToGround\",\n    value: function onReturnToGround() {\n      _get(_getPrototypeOf(GameCharacter.prototype), \"onReturnToGround\", this).call(this);\n\n      this.isCurrentlyTakingDamage = false; // Reset currently-taking-damage flag once damage freefall completes\n    }\n  }, {\n    key: \"die\",\n    value: function die() {\n      this.setAnimation('dead');\n      this.isDead = true; // Increase the freefall velocity a bit\n\n      this.freefall.velocity.x *= 1.5;\n      this.freefall.velocity.y *= 1.5;\n      this.freefall.velocity.z *= 1.5;\n\n      if (this.onDie) {\n        this.onDie();\n      }\n    }\n  }]);\n\n  return GameCharacter;\n}(GameObject), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"courage\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 2;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"damageDealt\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"kills\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"attack\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"attack\"), _class.prototype), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"doAttackDamage\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    var _this2 = this;\n\n    return function () {\n      var attackBox = _this2.getAttackBox();\n\n      _this2.gameState.getGameObjectsInsideBox(attackBox).forEach(function (gameObject) {\n        if (gameObject !== _this2 && gameObject.canTakeDamage && !gameObject.isDead) {\n          gameObject.takeDamage(1, _this2.direction === directions.right ? directions.left : directions.right, _this2);\n        }\n      });\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"takeDamage\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"takeDamage\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"onReturnToGround\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"onReturnToGround\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"die\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"die\"), _class.prototype)), _class);\nexport default GameCharacter;","map":{"version":3,"sources":["C:/Users/Admin/Documents/Crane/Capstone-Crane/src/state/GameCharacter.js"],"names":["GameObject","action","observable","directions","DAMAGE_FLYBACK_X","DAMAGE_FLYBACK_Y","DAMAGE_RANGE_NEAR_X","DAMAGE_RANGE_FAR_X","DAMAGE_RANGE_Z","GameCharacter","props","canTakeDamage","isDead","getAttackBox","minX","maxX","direction","right","position","x","collisionWidth","min","max","y","collisionHeight","z","onDie","animation","damageDelay","isMovementFrozen","onGround","attacking","setAnimation","duration","animationTracks","freezeMovement","attackDamageTimeout","setTimeout","doAttackDamage","damage","fromDirection","fromGameCharacter","isCurrentlyTakingDamage","courage","damageDealt","clearMovementFreezes","clearTimeout","setFreefall","left","die","kills","freefall","velocity","attackBox","gameState","getGameObjectsInsideBox","forEach","gameObject","takeDamage"],"mappings":"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","sourcesContent":["import GameObject from './GameObject'\r\nimport { action, observable } from 'mobx'\r\nimport directions from '../shared/enum/directions'\r\n\r\n// A GameObject that can attack and take damage\r\n\r\nconst DAMAGE_FLYBACK_X = 4\r\nconst DAMAGE_FLYBACK_Y = 5\r\n\r\nconst DAMAGE_RANGE_NEAR_X = 25\r\nconst DAMAGE_RANGE_FAR_X = 30\r\nconst DAMAGE_RANGE_Z = 15\r\n\r\nclass GameCharacter extends GameObject {\r\n\r\n  @observable\r\n  courage = 2\r\n\r\n  @observable\r\n  damageDealt = 0\r\n\r\n  @observable\r\n  kills = 0\r\n\r\n  canTakeDamage = true\r\n  isDead = false\r\n\r\n  constructor( props ) {\r\n    super( props )\r\n    this.onDie = props.onDie\r\n  }\r\n\r\n  @action\r\n  attack( animation, damageDelay ) {\r\n    if ( !this.isMovementFrozen() && this.onGround ) {\r\n      this.attacking = true\r\n      this.setAnimation( animation )\r\n      const { duration } = this.animationTracks[ animation ]\r\n      this.freezeMovement( duration, 'attack' )\r\n      \r\n      this.attackDamageTimeout = setTimeout( this.doAttackDamage, damageDelay )\r\n    }\r\n  }\r\n\r\n  getAttackBox = () => {\r\n    let minX, maxX\r\n\r\n    if ( this.direction === directions.right ) {\r\n      minX = this.position.x + this.collisionWidth + DAMAGE_RANGE_NEAR_X\r\n      maxX = this.position.x + this.collisionWidth + DAMAGE_RANGE_FAR_X\r\n    } else {\r\n      maxX = this.position.x - DAMAGE_RANGE_NEAR_X\r\n      minX = this.position.x - DAMAGE_RANGE_FAR_X\r\n    }\r\n\r\n    return {\r\n      x: { min: minX, max: maxX },\r\n      y: { min: this.position.y, max: this.position.y + this.collisionHeight },\r\n      z: { min: this.position.z - DAMAGE_RANGE_Z, max: this.position.z + DAMAGE_RANGE_Z }\r\n    }\r\n  }\r\n\r\n  @action\r\n  doAttackDamage = () => {\r\n    const attackBox = this.getAttackBox()\r\n\r\n    this.gameState.getGameObjectsInsideBox(attackBox).forEach( gameObject => {\r\n      if ( gameObject !== this && gameObject.canTakeDamage && !gameObject.isDead ) {\r\n        gameObject.takeDamage( 1, this.direction === directions.right ? directions.left : directions.right, this )\r\n      }\r\n    })\r\n  }\r\n\r\n  @action\r\n  takeDamage( damage, fromDirection, fromGameCharacter ) {\r\n    if ( this.isCurrentlyTakingDamage ) {\r\n      return\r\n    }\r\n\r\n    this.courage -= damage\r\n    fromGameCharacter.damageDealt += damage\r\n\r\n    this.clearMovementFreezes() // Clear movement freezes because the character is about to be knocked backwards\r\n    clearTimeout( this.attackDamageTimeout ) // Interrupt any in-progress attack\r\n    this.isCurrentlyTakingDamage = true\r\n\r\n    this.setAnimation( 'take_damage' )\r\n    this.direction = fromDirection\r\n\r\n    this.setFreefall({\r\n      x: fromDirection === directions.left ? DAMAGE_FLYBACK_X : -DAMAGE_FLYBACK_X,\r\n      y: DAMAGE_FLYBACK_Y,\r\n      z: 0\r\n    })\r\n\r\n    if ( this.courage <= 0 ) {\r\n      this.die()\r\n      fromGameCharacter.kills += 1\r\n    }\r\n  }\r\n\r\n  @action\r\n  onReturnToGround() {\r\n    super.onReturnToGround()\r\n    this.isCurrentlyTakingDamage = false // Reset currently-taking-damage flag once damage freefall completes\r\n  }\r\n\r\n  @action\r\n  die() {\r\n    this.setAnimation( 'dead' )\r\n    this.isDead = true\r\n    // Increase the freefall velocity a bit\r\n    this.freefall.velocity.x *= 1.5\r\n    this.freefall.velocity.y *= 1.5\r\n    this.freefall.velocity.z *= 1.5\r\n\r\n    if ( this.onDie ) {\r\n      this.onDie()\r\n    }\r\n  }\r\n}\r\n\r\nexport default GameCharacter"]},"metadata":{},"sourceType":"module"}